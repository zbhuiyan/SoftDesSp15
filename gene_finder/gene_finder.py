# -*- coding: utf-8 -*-
"""
Created on Sun Feb  2 11:24:42 2014

@author: Zarin Bhuiyan

"""

# you may find it useful to import these variables (although you are not required to use them)
from amino_acids import aa, codons, aa_table
import random
from load import load_seq

def shuffle_string(s):
    """ Shuffles the characters in the input string
        NOTE: this is a helper function, you do not have to modify this in any way """
    return ''.join(random.sample(s,len(s)))

### YOU WILL START YOUR IMPLEMENTATION FROM HERE DOWN ###


def get_complement(nucleotide):
    """ Returns the complementary nucleotide

        nucleotide: a nucleotide (A, C, G, or T) represented as a string
        returns: the complementary nucleotide
    >>> get_complement('A')
    'T'
    >>> get_complement('C')
    'G'
    """
    # TODO: implement this
    if nucleotide == "A":
        return "T"
    elif nucleotide == "T":
        return "A"
    elif nucleotide == "C":
        return "G"
    elif nucleotide == "G":
         return "C"
    else:
        print("Not valid input")




    

def get_reverse_complement(dna):
    """ Computes the reverse complementary sequence of DNA for the specfied DNA
        sequence
    
        dna: a DNA sequence represented as a string
        returns: the reverse complementary DNA sequence represented as a string
    >>> get_reverse_complement("ATGCCCGCTTT")
    'AAAGCGGGCAT'
    >>> get_reverse_complement("CCGCGTTCA")
    'TGAACGCGG'
    """
    # TODO: implement this

    if len(dna) <= 1:
        return dna

    else:
        reverse_dna = dna[::-1]
        #return reverse_dna

        reverse_list = list (reverse_dna)
        new_list = []


        for i in reverse_list:

            new_list.append(get_complement(i))



            

        return ''.join(new_list)

#print get_reverse_complement("ATGCCCGCTTT")







def rest_of_ORF(dna):
    """ Takes a DNA sequence that is assumed to begin with a start codon and returns
        the sequence up to but not including the first in frame stop codon.  If there
        is no in frame stop codon, returns the whole string.
        
        dna: a DNA sequence
        returns: the open reading frame represented as a string
    >>> rest_of_ORF("ATGTGAA")
    'ATG'
    >>> rest_of_ORF("ATGAGATAGG")
    'ATGAGA'
    """
    # TODO: implement this
    x = [dna[i:i+3] for i in range(0,len(dna),3)]

    for i in range(len(x)):
    
        if (x[i] == 'TAG') or (x[i] == 'TGA') or (x[i] == 'TAA'):
            return dna[0:i*3]
        else:
            return dnahttp://www.hot97.com/



def find_all_ORFs_oneframe(dna):
    """ Finds all non-nested open reading frames in the given DNA sequence and returns
        them as a list.  This function should only find ORFs that are in the default
        frame of the sequence (i.e. they start on indices that are multiples of 3).
        By non-nested we mean that if an ORF occurs entirely within
        another ORF, it should not be included in the returned list of ORFs.
        
        dna: a DNA sequence
        returns: a list of non-nested ORFs
    >>> find_all_ORFs_oneframe("ATGCATGAATGTAGATAGATGTGCCC")
    ['ATGCATGAATGTAGA', 'ATGTGCCC']
    """
    # TODO: implement this


    x = [dna[i:i+3] for i in range(0,len(dna),3)]
    all_orfs=[]
    c = 0

    while len(x)>0:
    

        if x[c] == 'ATG':
            rest = rest_of_ORF(dna[c*3:])
            #rest = rest[:len(rest) - 3]
            #x = x[len(rest):]
            all_orfs.append('ATG' + rest)
        else:
            x = x[1:]
    return all_orfs


print find_all_ORFs_oneframe("ATGCATGAATGTAG")






            





# def find_all_ORFs(dna):
#     """ Finds all non-nested open reading frames in the given DNA sequence in all 3
#         possible frames and returns them as a list.  By non-nested we mean that if an
#         ORF occurs entirely within another ORF and they are both in the same frame,
#         it should not be included in the returned list of ORFs.
        
#         dna: a DNA sequence
#         returns: a list of non-nested ORFs

#     >>> find_all_ORFs("ATGCATGAATGTAG")
#     ['ATGCATGAATGTAG', 'ATGAATGTAG', 'ATG']
#     """
#     # TODO: implement this
#     pass

# def find_all_ORFs_both_strands(dna):
#     """ Finds all non-nested open reading frames in the given DNA sequence on both
#         strands.
        
#         dna: a DNA sequence
#         returns: a list of non-nested ORFs
#     >>> find_all_ORFs_both_strands("ATGCGAATGTAGCATCAAA")
#     ['ATGCGAATG', 'ATGCTACATTCGCAT']
#     """
#     # TODO: implement this
#     pass


# def longe st_ORF(dna): 
#     """ Finds the longest ORF on both strands of the specified DNA and returns it
#         as a string
#     >>> longest_ORF("ATGCGAATGTAGCATCAAA")
#     'ATGCTACATTCGCAT'
#     """
#     # TODO: implement this
#     pass


# def longest_ORF_noncoding(dna, num_trials):
#     """ Computes the maximum length of the longest ORF over num_trials shuffles
#         of the specfied DNA sequence
        
#         dna: a DNA sequence
#         num_trials: the number of random shuffles
#         returns: the maximum length longest ORF """
#     # TODO: implement this
#     pass

# def coding_strand_to_AA(dna):
#     """ Computes the Protein encoded by a sequence of DNA.  This function
#         does not check for start and stop codons (it assumes that the input
#         DNA sequence represents an protein coding region).
        
#         dna: a DNA sequence represented as a string
#         returns: a string containing the sequence of amino acids encoded by the
#                  the input DNA fragment

#         >>> coding_strand_to_AA("ATGCGA")
#         'MR'
#         >>> coding_strand_to_AA("ATGCCCGCTTT")
#         'MPA'
#     """
#     # TODO: implement this
#     pass

# def gene_finder(dna, threshold):
#     """ Returns the amino acid sequences coded by all genes that have an ORF
#         larger than the specified threshold.
        
#         dna: a DNA sequence
#         threshold: the minimum length of the ORF for it to be considered a valid
#                    gene.
#         returns: a list of all amino acid sequences whose ORFs meet the minimum
#                  length specified.
#     """
#     # TODO: implement this
#     pass

if __name__ == "__main__":
    import doctest
    doctest.testmod()
